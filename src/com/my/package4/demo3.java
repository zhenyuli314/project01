package com.my.package4;
/*
* super关键字的使用
1.supe理解为：父类的2.supe可以用来调用：属性、方法、构造器
3. super的使用：调用属性和方法
    3.1我们可以在子类的方法或构造器中。通过使用" super.属性"或" super.方法"的方式，
    * 显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略" super."
    3.2特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，
    * 则必须显式的使用" super.属性"的方式，表明调用的是父类中声明的属性。
    3.3特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，
    * 则必须显式的使用" super，方法"的方式，表明调用的是父类中被重写的方法。
4.调用构造器
    4.1我们可以在子类的构造器中显式的使用" super（形参列表）"的方式，调用父类中声明的指定的构造器
    4.2" super（形参列表）"的使用，必须声明在子类构造器的首行
    4.3我们在类的构造器中，针对于"this（形参列表）”或” super（形参列表）”只能二选一
    4.4在构造器的首行，没有显式的声明"this（形参列表）"或" super（形参列表）"，则默认调用的是父类中空参的构造：super()
    4.5在类的多个构造器中，至少有一个类的构造器中使用了" super（形参列表）"，调用父类中的构造器
    *
    当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，
    直到调用了jaVa.1ang. Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，
    子类对象才可以考虑进正调用。

    明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。
    ****************************************************************
子类对象实例化的全过程
1.从结果上来看：（继承性）
子类继承父类以后，就获取了父类中声明的属性或方法创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。
2.从过程上来看当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，
直到调用了jaVa.1ang. Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，
子类对象才可以考虑进行调用。

* 明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。
   *
* */
public class demo3 {
}
